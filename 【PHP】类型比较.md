##### 分类

###### 松散比较

&emsp;&emsp;使用 **==** 比较，只比较值，不比较类型。

###### 严格比较

&emsp;&emsp;使用 **===** 比较，不仅比较值，也比较类型。

```php
<?php
if(42=="42"){
    echo "1、值相等";
}

echo PHP_EOL;

if(42==="42"){
    echo "2、类型相等";
}
else{
    echo "3、类型不相等";
}
?>
/*输出：
1、值相等
3、类型不相等
*/
```

##### 松散比较实例

######  字符串与数字比较

&emsp;&emsp;字符串与数字比较时会试图将字符串转换为数字，如果字符串是以数字开头，那么就会直接转换成这个数字。

```php
var_dump("a"==0);	//bool(true)
var_dump("1a"==1);	//bool(true)
var_dump("12a"==1);	//bool(false)
```

- 第一个：a 转换为数字失败，成为 bool 型量 false ，而 false 与 0 进行 == 比较是相等的，所以最终结果为 true 。
- 二、三：分别转换为 1 、12。

###### 布尔true与任意类型比较

​		bool true 与任何比较都相等，除了 0 和 false（0也认为是bool false）。

```php
var_dump(true==0);	        //bool(false)
var_dump(true=="false");	//bool(true)
var_dump(true==2);	        //bool(true)
```

###### md5值与字符串"0"比较

前置知识：

```php
var_dump("0"==0); //bool(true)
var_dump("0c"==0); //bool(ture)
var_dump("0"=="0c"); //bool(false)
/*
？按照传递性，为什么第三组不是bool(true)？
其实因为是俩字符串进行比较，类型相同，不必再进行值的转换，不能用传递性来思考
```

来看：

```php
$str1 = "a";
echo md5($str1);	//0cc175b9c0f1b6a831c399e269772661
var_dump(md5($str1)=="0");	//bool(false)
---------------------------------------------------------
$str2 = "s224534898e";
echo md5($str2);	//0e420233178946742799316739797882
var_dump(md5($str2)=="0");	//bool(true)
---------------------------------------------------------
$str3 = "a1b2edaced";
echo md5($str3);	//0e45ea817f33691a3dd1f46af81166c4
var_dump(md5($str3)=="0");	//bool(false)
```

&emsp;&emsp;？按理来说，三组都是俩字符串进行比较，为什么第二组是 bool(true) ？且看实验过程：

```php
var_dump("1c"); //string(2) "1c"
var_dump("1c"+1); //int(2)，并抛出错误
var_dump("c"+1); //int(1)，并抛出错误
```

&emsp;&emsp;说明字符串与数字进行运算操作的时候，也会试图将字符串转换为数字，如果字符串是以数字开头，那么就会直接转换成这个数字。

```php
var_dump("2e1"+1); //float(21)
var_dump("2e1c"+1); //float(21)，并抛出错误
```

&emsp;&emsp;说明当字符串为 `^[0-9]+e[0-9]` 模式时，将试图把字符串转换为用科学计数法表示的数，设为 x ，最终变成 "x" 。

&emsp;&emsp;现在我们来解释一下三组 md5 值与 "0" 比较的结果：

- 第一组：非 `^[0-9]+e[0-9]` 模式，则为两字符串比较，内容不同，显然是 bool(false) 。
- 第二组：`^[0-9]+e[0-9]` 模式，将转换为数字，得到 "0" ，与 "0" 进行 == 比较得到 bool(true) 。
- 第三组（只能这样理解，欢迎指正）：`^[0-9]+e[0-9]` 模式，但不是真正的科学计数法表示的数，强制转换将抛出错误，所以 PHP 索性将其当作不会抛出错误的（即相对而言最正确的）东西——字符串，则为两字符串比较，同第一组，得到 bool(false) 。
